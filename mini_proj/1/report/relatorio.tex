\documentclass[twocolumn]{article}

\usepackage{algorithm,algpseudocode,caption}

\usepackage[portuguese]{babel}
\usepackage{comment}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{multirow}
\usepackage{indentfirst}
\usepackage[hypcap]{caption} % makes \ref point to top of figures and tables

\begin{document}

\input{./rosto.tex}
\hypersetup{%
    pdfborder = {0 0 0}
}
\pagenumbering{arabic}
\section{Descrição do problema}
Neste mini-projecto, pretende-se a implementação de diversas funções relacionadas com a transmissão de dados em pacotes consoante
o seu destino.

Nesta fase, apenas se desenvolveram funções de conversão de \textit{forwarding table} para \textit{binary tree}, desta última para
\textit{binary2-tree}, adição de novos prefixos, remoção de prefixos e impressão de uma árvore binária no formato de
\textit{forwarding table}.

\section{Função \textit{ReadTable}}
Nesta função o programa deverá ler de um ficheiro os prefixos de uma tabela e os correspondentes \textit{next hops} e criar a 
árvore binária correspondente.
Como tal, a função irá ler do ficheiro um prefixo de cada vez, adicionando-o à árvore com o \textit{next hop} correspondente.

O pseudo-código da função será o seguinte:

\begin{algorithmic}
 \State $root node creation()\;$
 \While{$there\_are\_lines\_in\_the\_document$}
   \State $get\_table\_line()\;$
  
   \State $ AddPrefix()\;$
 \EndWhile
 
\Return\;
 \caption{ReadTable}
\end{algorithmic}
Desta forma, sendo o objectivo a inserção de todos os prefixos, será necessário fazer \textit{n} vezes a chamada à função \textit{AddPrefix}. A complexidade do algoritmo será assim O(n)O(get\_table\_line).
%conferir complexidade do algoritmo

\section{Função \textit{AddPrefix}}
Tal como descrito no enunciado, a função tem por objectivo a adição de um novo prefixo à árvore binária. Assumimos que esta função apenas é chamada quando a árvore binária do programa já foi previamente inicializada, ou seja, apenas é chamada dentro da função \textit{ReadTable}, onde o \textit{root node} é inicializado internamente, ou depois desta ser realizada.

Nesta função, testa-se se o prefixo a colocar na árvore é válido. No caso de ser, verifica se o prefixo é do \textit{root} ou se é um endereço binário. Se for do \textit{root}, copiam-se as informações directamente para a estrutura apontada pelo ponteiro. Se não for, ir-se-á percorrer os nós da árvore correspondentes (criando os não existentes no caminho), copiando os valores pretendidos na estrutura correspondente ao prefixo indicado.

%PERGUNTAR AO PROF!!!!!!!!!
No pior caso, o algoritmo implementado terá de percorrer a altura da árvore. A complexidade irá ser O(Comprimento do prefixo).
O pseudo-código da função será o seguinte:
\begin{algorithmic}
 \If{$adress\_is\_invalid$}{
 	\Return\;
 \EndIf
 \If{$adress\_is\_"*"$}{\Comment{root prefix}
 	\State $root->next\_hop:=next\_hop\;$
 	
 	\State $root->prefix:=prefix\;$
 \Else
    \State $auxiliar\_node:=root\_node\;$
 	\While{$all\_prefix\_nodes\_havent\_been\_visited\_yet$}{
 		\If{$bit\_is\_0$}{
 			\If{$there\_is\_no\_node$}
 				\State $node\_creation()\;$
 			\EndIf
 			\State $auxiliar:=auxiliar->zero\;$
 		\Else \Comment{bit is one} 			
 			\If{$there\_is\_no\_node$}
 				\State $node\_creation()\;$
 			\EndIf
 			\State $auxiliar:=auxiliar->one\;$
 		\EndIf
		\State $auxiliar->next\_hop:=next\_hop\;$ 	
 	\EndWhile
 \EndIf
 \caption{AddPrefix}
\end{algorithmic}

\section{Função \textit{DeletePrefix}}
Nesta função, assumimos os seguintes factos: o comando de \textit{delete} do \textit{root} deve ser considerado como inválido, e no caso de se apagar um prefixo que seja "filho único" o "pai" também deve ser removido.

Assim, no início da função, esta faz chamadas recursivas a ela própria até atingir o prefixo pretendido, retornando com uma mensagem de erro no caso de este não existir.
 A função \textit{new\_prefix} corresponde a retirar ao prefixo a apagar um bit, de forma a que o caminho a percorrer se inicie no bit onde a função se encontra de momento. %ACRESCIMO
Após apagar o nó correspondente, a função, ao retornar 1, "avisa" o nó de cima ("pai") de que o ponteiro para este será agora NULL. Este factor será bastante importante na medida em que a condição de \textit{free} baseia-se no facto de os dois ponteiros para estruturas "filho" serem NULL.

A complexidade do algoritmo será O(comprimento do prefixo). %PERGUNTAR
O pseudo-código da função será o seguinte:
\begin{algorithmic}
 \If{$prefix\_corresponds\_to\_root$}
 	\Return -1\;
 \EndIf
 \If{$havent\_reached\_the\_end\_of\_the\_prefix\_bits$}
 	\If{$bit=0$}
 		\State $prefix:=new\_prefix()\;$
 		
 		\If{$node\_exists$}
 			\If{$Delete\_prefix(base\_node->zero, prefix)=1$}
 				\State $base\_node->zero:=NULL\;$
 			\EndIf
 		\Else
 			\State $prefix\_does\_not\_exist\;$
 			\Return -1\;
 		\EndIf
 	\Else
 		\If{$bit=1$}
 			\State $prefix:=new\_prefix()\;$
 		
 			\If{$node\_exists$}
 				\If{$Delete\_prefix(base\_node->one, prefix)=1$}
 					\State $base\_node->one:=NULL\;$
 				\EndIf
 			\Else
 				\State $prefix\_does\_not\_exist\;$
 				\Return -1\;
 			\EndIf
 		\EndIf
 	\EndIf
 \Else
 	\If{$node\_has\_no\_children$}
 		\State $Free\_node(base\_node)\;$
 		\Return 1\;
 	\Else
		\State $base\_node->next\_hop:=-1\;$\Comment{cant free the node but erases next hop}	
 	\EndIf
 \EndIf
 \Return 0\;
 \caption{DeletePrefix}
\end{algorithmic}
\section{Função \textit{PrintTable}}
Neste caso, pretende-se a conversão de uma árvore binária numa \textit{forwarding table}. Para tal, será necessário visitar todos os nós da árvore, verificando se têm \textit{next hop} atribuído. Assim:

\begin{algorithmic}
 \If{$has\_next\_hop$}{
	\State $print\_node\_prefix\_and\_next\_hop\;$
 \EndIf
 \If{$has\_"0"\_child$}
	\State $PrintTable(zero\_child)\;$
 \EndIf
 \If{$has\_"1"\_child$}
	\State $PrintTable(one\_child)\;$
 \EndIf
 
 \Return\;
 \caption{PrintTable}
\end{algorithmic}
A árvore será assim percorrida em profundidade, da esquerda para a direita.

\section{Função \textit{TwoTree}}
Com esta função, pretende-se a conversão da árvore obtida anteriormente pela função \textit{ReadTable} para uma \textit{binary}2-\textit{tree}. Por definição, neste tipo de árvore, todos os nós que não são folhas têm exactamente dois "filhos". Desta forma, o algoritmo percorre recursivamente os nós da árvore. Se ao chegar a uma folha e a mesma não tiver um valor de \textit{next hop} atribuído actualiza-o. Caso o nó não seja uma folha, verifica qual a ramificação em falta, cria-a e chama a rotina para cada ramo. A função tem como parâmetros de entrada um ponteiro para o topo da árvore/sub-árvore, bem como o valor de \textit{next hop} que irá ser atribuído às folhas da ramificação em  causa. A função \textit{update\_next\_hop} tem como função verificar se o \textit{next\_hop} a utilizar na chamada recursiva é o mesmo no nó anterior ou um valor actualizado, no caso de o valor do nó visitado ser diferente.
O pseudo-código da função será o seguinte:
\begin{algorithmic}
 \If{$node\_is\_a\_leaf$}
 	\If{$has\_no\_next\_hop$}
 		\State $base\_node->next\_hop:=next\_hop\;$
 	\EndIf
 \Else
 	\If{$has\_no\_"0"\_child$}
 		\State $prefix:=new\_node\_prefix()\;$
 		\State $create\_zero\_child(prefix)\;$
 	\Else
		\If{$has\_no\_"1"\_child$}	
			\State $prefix:=new\_node\_prefix()\;$
			\State $create\_one\_child(prefix)\;$
		\EndIf
 	\EndIf
 	\State $TwoTree(base\_node->zero, update\_next\_hop())\;$
 	\State $TwoTree(base\_node->one, update\_next\_hop())\;$
 \EndIf
 
 \Return\;
 \caption{TwoTree}
\end{algorithmic}

\section{Função \textit{AdressLookUp}}
Com esta rotina, pretende-se retornar o \textit{next\_hop} do prefixo em causa. Considerando a ordem do enunciado, assume-se que a árvore a utilizar para obter a informação é do tipo \textit{binary}2-\textit{tree}. Como tal, toda a informação relativa aos \textit{next\_hops} estão contidas nas folhas da árvore. Assim, recebendo como argumentos de \textit{input} o ponteiro para o topo da árvore e o prefixo desejado, o algoritmo em causa percorre os nós consoante os \textit{bits} do prefixo especificado até que o ponteiro de um nó para o seu "filho" seja NULL. Quando tal acontecer significa que o nó para o qual o ponteiro auxiliar aponta é uma folha da árvore, cujo nó contém o \textit{next\_hop} mais específico para o prefixo dado no \textit{input}.
O pseudo-código da função será o seguinte:
\begin{algorithmic}
 \If{$prefix\_is\_invalid$}
 	\Return $-1\;$
 \EndIf
 
 \State $auxiliar:=root\;$
 
 \While{$havent\_reached\_the\_end\_of\_prefix\_bits$}
 	\If{$bit=0$}
 		\If{$has\_no\_"0"\_child$}{
 			\Return $auxiliar->next\_hop\;$
 		\EndIf
 		\State $auxiliar:=auxiliar->zero\;$
 	\Else
 		\If{$has\_no\_"1"\_child$}
 			\Return $auxiliar->next\_hop\;$
 		\EndIf
 		\State $auxiliar:=auxiliar->one\;$
 	\EndIf
 \EndWhile
 
 \Return -1\;
 \caption{AdressLookUp}
\end{algorithmic}
\section{Considerações finais}

\end{document}