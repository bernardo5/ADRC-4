\documentclass[a4paper]{article}

\usepackage[]{algorithm2e}
\usepackage[portuguese]{babel}
\usepackage{comment}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{multirow}
\usepackage{indentfirst}
\usepackage[hypcap]{caption} % makes \ref point to top of figures and tables

\begin{document}

\input{./rosto.tex}
\hypersetup{%
    pdfborder = {0 0 0}
}
\pagenumbering{arabic}
\section{Descrição do problema}
Neste mini-projecto, pretende-se a implementação de diversas funções relacionadas com a transmissão de dados em pacotes consoante
o seu destino.

Nesta fase, apenas se desenvolveu funções de conversão de \textit{forwarding table} para \textit{binary tree}, desta última para
\textit{binary2-tree}, adição de novos prefixos, remoção de prefixos e impressão de uma árvore binária no formato de
\textit{forwarding table}.

\section{Função \textit{ReadTable}}
Nesta função o programa deverá ler de um ficheiro os prefixos de uma tabela e os correspondentes \textit{next hops} e criar a 
árvore binária correspondente.
Como tal, a função irá ler do ficheiro um prefixo de cada vez, adicionando-o à árvore com o \textit{next hop} correspondente.

O pseudo-código da função será o seguinte:

\begin{algorithm}[H]
 root node creation()\;
 \While{there are lines in the document}{
  get\_table\_line()\;
  
  AddPrefix()\;
 }
 \caption{ReadTable}
\end{algorithm}
Desta forma, sendo o objectivo a inserção de todos os prefixos, será necessário fazer \textit{n} vezes a chamada à função \textit{AddPrefix}. A complexidade do algoritmo será assim O(n)O(get\_table\_line).
%conferir complexidade do algoritmo

\section{Função \textit{AddPrefix}}
Tal como descrito no enunciado, a função tem por objectivo a adição de um novo prefixo à árvore binária. Assumimos que esta função apenas é chamada quando a árvore binária do programa já foi previamente inicializada, ou seja, apenas é chamada dentro da função \textit{ReadTable}, onde o \textit{root node} é inicializado internamente, ou depois desta ser realizada.

Nesta função, testa-se se o prefixo a colocar na árvore é válido. No caso de ser, verifica se o prefixo é do \textit{root} ou se é um endereço binário. Se for do \textit{root}, copia as informações directamente para a estrutura apontada pelo ponteiro. Se não for, irá percorrer os nós da árvore correspondentes (criando os não existentes no caminho), copiando os valores pretendidos na estrutura correspondente ao prefixo indicado.

%PERGUNTAR AO PROF!!!!!!!!!
No pior caso, o algoritmo implementado terá de percorrer a altura da árvore. A complexidade irá ser O(Comprimento do prefixo).

\begin{algorithm}[H]
 \If{adress is invalid}{
 	\Return\;
 }
 \eIf{adress is "*" (root)}{
 	root->next\_hop:=next\_hop\;
 	
 	root->prefix:=prefix\;
 }{
    auxiliar\_node:=root\_node\;
 	\While{all prefix nodes havent been visited yet}{
 		\eIf{bit is 0}{
 			\If{there is no node}{
 				node creation()\;
 			}
 			auxiliar:=auxiliar->zero\;
 		}{
 			/*bit is one*/
 			
 			\If{there is no node}{
 				node creation()\;
 			}
 			auxiliar:=auxiliar->one\;
 		}
		auxiliar->next\_hop:=next\_hop\; 	
 	}
 }
 \caption{AddPrefix}
\end{algorithm}

\section{Função \textit{DeletePrefix}}
Nesta função, assumimos os seguintes factos: o comando de \textit{delete} do \textit{root} deve ser considerado como inválido e no caso de se apagar um prefixo que seja "filho único" o "pai" também deve ser removido.

Assim, no início da função, esta faz chamadas recursivas a ela própria até atingir o prefixo pretendido, retornando com uma mensagem de erro no caso de este não existir. Após apagar o nó correspondente, a função, ao retornar 1, "avisa" o nó de cima de que o ponteiro para este será agora NULL. Este factor será bastante importante na medida em que a condição de \textit{free} baseia-se no facto de os dois ponteiros para estruturas "filho" serem NULL.
%da lhe ai xD 
\section{Função \textit{PrintTable}}
Neste caso, pretende-se a conversão de uma árvore binária numa \textit{forwarding table}. Para tal, será necessário visitar todos os nós da árvore, verificando se têm \textit{next hop} atribuído. Assim:

\begin{algorithm}[H]
 \If{has next hop}{
	print node prefix and next hop value\;
 }
 \If{has "0" child}{
	PrintTable(zero child)\;
 }
 \If{has "1" child}{
	PrintTable(zero child)\;
 }
 \Return\;
 \caption{PrintTable}
\end{algorithm}
A árvore será assim percorrida em profundidade, da esquerda para a direita.
\section{Considerações finais}

\end{document}