\documentclass[a4paper]{article}

\usepackage[]{algorithm2e}
\usepackage[portuguese]{babel}
\usepackage{comment}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{multirow}
\usepackage{indentfirst}
\usepackage[hypcap]{caption} % makes \ref point to top of figures and tables

\begin{document}

\input{./rosto.tex}
\hypersetup{%
    pdfborder = {0 0 0}
}
\pagenumbering{arabic}
\section{Descrição do problema}
Neste mini-projecto, pretende-se a implementação de diversas funções relacionadas com a transmissão de dados em pacotes consoante
o seu destino.

Nesta fase, apenas se desenvolveu funções de conversão de \textit{forwarding table} para \textit{binary tree}, desta última para
\textit{binary2-tree}, adição de novos prefixos, remoção de prefixos e impressão de uma árvore binária no formato de
\textit{forwarding table}.

\section{Função \textit{ReadTable}}
Nesta função o programa deverá ler de um ficheiro os prefixos de uma tabela e os correspondentes \textit{next hops} e criar a 
árvore binária correspondente.
Como tal, a função irá ler do ficheiro um prefixo de cada vez, adicionando-o à árvore com o \textit{next hop} correspondente.

O pseudo-código da função será o seguinte:

\begin{algorithm}[H]
 root node creation()\;
 \While{there are lines in the document}{
  get\_table\_line()\;
  
  AddPrefix()\;
 }
 \caption{ReadTable}
\end{algorithm}
Desta forma, sendo o objectivo a inserção de todos os prefixos, será necessário fazer \textit{n} vezes a chamada à função \textit{AddPrefix}. A complexidade do algoritmo será assim O(n)O(get\_table\_line).
%conferir complexidade do algoritmo

\section{Função \textit{AddPrefix}}
Tal como descrito no enunciado, a função tem por objectivo a adição de um novo prefixo à árvore binária. Assumimos que esta função apenas é chamada quando a árvore binária do programa já foi previamente inicializada, ou seja, apenas é chamada dentro da função \textit{ReadTable}, onde o \textit{root node} é inicializado internamente, ou depois desta ser realizada.

Nesta função, testa-se se o prefixo a colocar na árvore é válido. No caso de ser, verifica se o prefixo é do \textit{root} ou se é um endereço binário. Se for do \textit{root}, copia as informações directamente para a estrutura apontada pelo ponteiro. Se não for, irá percorrer os nós da árvore correspondentes (criando os não existentes no caminho), copiando os valores pretendidos na estrutura correspondente ao prefixo indicado.

%PERGUNTAR AO PROF!!!!!!!!!
No pior caso, o algoritmo implementado terá de percorrer a altura da árvore. A complexidade irá ser O(Comprimento do prefixo).

\begin{algorithm}[H]
 \If{adress is invalid}{
 	\Return\;
 }
 \eIf{adress is "*" (root)}{
 	root->next\_hop:=next\_hop\;
 	
 	root->prefix:=prefix\;
 }{
    auxiliar\_node:=root\_node\;
 	\While{all prefix nodes havent been visited yet}{
 		\eIf{bit is 0}{
 			\If{there is no node}{
 				node creation()\;
 			}
 			auxiliar:=auxiliar->zero\;
 		}{
 			/*bit is one*/
 			
 			\If{there is no node}{
 				node creation()\;
 			}
 			auxiliar:=auxiliar->one\;
 		}
		auxiliar->next\_hop:=next\_hop\; 	
 	}
 }
 \caption{AddPrefix}
\end{algorithm}

\section{Função \textit{DeletePrefix}}

\section{Considerações finais}

\end{document}