\documentclass[a4paper]{article}

\usepackage[]{algorithm2e}
\usepackage[portuguese]{babel}
\usepackage{comment}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{multirow}
\usepackage{indentfirst}
\usepackage[hypcap]{caption} % makes \ref point to top of figures and tables

\begin{document}

\input{./rosto.tex}
\hypersetup{%
    pdfborder = {0 0 0}
}
\pagenumbering{arabic}
\section{Descrição do problema}
Neste mini-projecto, pretende-se a implementação de diversas funções relacionadas com a transmissão de dados em pacotes consoante
o seu destino.

Nesta fase, apenas se desenvolveu funções de conversão de \textit{forwarding table} para \textit{binary tree}, desta última para
\textit{binary2-tree}, adição de novos prefixos, remoção de prefixos e impressão de uma árvore binária no formato de
\textit{forwarding table}.

\section{Função \textit{ReadTable}}
Nesta função o programa deverá ler de um ficheiro os prefixos de uma tabela e os correspondentes \textit{next hops} e criar a 
árvore binária correspondente.
Como tal, a função irá ler do ficheiro um prefixo de cada vez, adicionando-o à árvore com o \textit{next hop} correspondente.

O pseudo-código da função será o seguinte:

\begin{algorithm}[H]
 root node creation()\;
 \While{there are lines in the document}{
  get\_table\_line()\;
  
  AddPrefix()\;
 }
 \caption{ReadTable}
\end{algorithm}
Desta forma, sendo o objectivo a inserção de todos os prefixos, será necessário fazer \textit{n} vezes a chamada à função \textit{AddPrefix}. A complexidade do algoritmo será assim O(n)O(get\_table\_line).
%conferir complexidade do algoritmo

\section{Função \textit{AddPrefix}}
Tal como descrito no enunciado, a função tem por objectivo a adição de um novo prefixo à árvore binária. Assumimos que esta função apenas é chamada quando a árvore binária do programa já foi previamente inicializada, ou seja, apenas é chamada dentro da função \textit{ReadTable}, onde o \textit{root node} é inicializado internamente, ou depois desta ser realizada.

Nesta função, testa-se se o prefixo a colocar na árvore é válido. No caso de ser, verifica se o prefixo é do \textit{root} ou se é um endereço binário. Se for do \textit{root}, copia as informações directamente para a estrutura apontada pelo ponteiro. Se não for, irá percorrer os nós da árvore correspondentes (criando os não existentes no caminho), copiando os valores pretendidos na estrutura correspondente ao prefixo indicado.

%PERGUNTAR AO PROF!!!!!!!!!
No pior caso, o algoritmo implementado terá de percorrer a altura da árvore. A complexidade irá ser O(Comprimento do prefixo).

\begin{algorithm}[H]
 \If{adress is invalid}{
 	\Return\;
 }
 \eIf{adress is "*" (root)}{
 	root->next\_hop:=next\_hop\;
 	
 	root->prefix:=prefix\;
 }{
    auxiliar\_node:=root\_node\;
 	\While{all prefix nodes havent been visited yet}{
 		\eIf{bit is 0}{
 			\If{there is no node}{
 				node creation()\;
 			}
 			auxiliar:=auxiliar->zero\;
 		}{
 			/*bit is one*/
 			
 			\If{there is no node}{
 				node creation()\;
 			}
 			auxiliar:=auxiliar->one\;
 		}
		auxiliar->next\_hop:=next\_hop\; 	
 	}
 }
 \caption{AddPrefix}
\end{algorithm}

\section{Função \textit{DeletePrefix}}
Nesta função, assumimos os seguintes factos: o comando de \textit{delete} do \textit{root} deve ser considerado como inválido e no caso de se apagar um prefixo que seja "filho único" o "pai" também deve ser removido.

Assim, no início da função, esta faz chamadas recursivas a ela própria até atingir o prefixo pretendido, retornando com uma mensagem de erro no caso de este não existir. Após apagar o nó correspondente, a função, ao retornar 1, "avisa" o nó de cima de que o ponteiro para este será agora NULL. Este factor será bastante importante na medida em que a condição de \textit{free} baseia-se no facto de os dois ponteiros para estruturas "filho" serem NULL.
%da lhe ai xD 
\section{Função \textit{PrintTable}}
Neste caso, pretende-se a conversão de uma árvore binária numa \textit{forwarding table}. Para tal, será necessário visitar todos os nós da árvore, verificando se têm \textit{next hop} atribuído. Assim:

\begin{algorithm}[H]
 \If{has next hop}{
	print node prefix and next hop value\;
 }
 \If{has "0" child}{
	PrintTable(zero child)\;
 }
 \If{has "1" child}{
	PrintTable(zero child)\;
 }
 \Return\;
 \caption{PrintTable}
\end{algorithm}
A árvore será assim percorrida em profundidade, da esquerda para a direita.

\section{Função \textit{TwoTree}}
Com esta função, pretende-se a conversão da árvore obtida anteriormente pela função \textit{ReadTable} para uma \textit{binary}2-\textit{tree}. Por definição, neste tipo de árvore, todos os nós que não são folhas têm exactamente dois "filhos". Desta forma, o algoritmo percorre recursivamente os nós da árvore. Se ao chegar a uma folha e a mesma não tiver um valor de \textit{next hop} atribuído, actualiza-o. Caso o nó não seja uma folha, verifica qual a ramificação em falta, cria-a e chama a rotina para cada ramo. A função tem como parâmetros de entrada um ponteiro para o topo da árvore/sub-árvore, bem como o valor de \textit{next hop} que irá ser atribuído às folhas da ramificação em  causa. A função \textit{update\_next\_hop} tem como função verificar se o \textit{next\_hop} a utilizar na chamada recursiva é o mesmo no nó anterior ou um valor actualizado, no caso de o valor do nó visitado ser diferente.

\begin{algorithm}[H]
 \eIf{node is a leaf}{
 	\If{has no next hop}{
 		base\_node->next\_hop:=next\_hop\;
 	}
 }{
 	\eIf{has no zero child}{
 		prefix:=new\_node\_prefix()\;
 		create\_zero\_child(prefix)\;
 	}{
		\If{has no one child}{	
			prefix:=new\_node\_prefix()\;
			create\_one\_child(prefix)\;
		}
 	}
 	TwoTree(base\_node->zero, update\_next\_hop())\;
 	TwoTree(base\_node->one, update\_next\_hop())\;
 }
 \Return\;
 \caption{TwoTree}
\end{algorithm}

\section{Função \textit{AdressLookUp}}
Com esta rotina, pretende-se retornar o \textit{next\_hop} de um prefixo em causa. Considerando a ordem do enunciado, assume-se que a árvore a utilizar para obter a informação é do tipo \textit{binary}2-\textit{tree}. Como tal, toda a informação relativa aos \textit{next\_hops} estão contidas nas folhas da árvore. Assim, recebendo como argumentos de \textit{input} o ponteiro para o topo da árvore e o prefixo desejado, o algoritmo em causa percorre os nós consoante os \textit{bits} do prefixo especificado até que o ponteiro de um nó para o seu "filho" seja NULL. Quando tal acontecer significa que o nó para o qual o ponteiro auxiliar aponta é uma folha da árvore, cujo nó contém o \textit{next\_hop} mais específico para o prefixo dado no \textit{input}.

\begin{algorithm}[H]
 \If{prefix is invalid}{
 	\Return -1\;
 }
 auxiliar:=root\;
 
 \While{havent reached the end of prefix bits}{
 	\eIf{bit=0}{
 		\If{has no zero child}{
 			\Return auxiliar->next\_hop\;
 		}
 		auxiliar:=auxiliar->zero\;
 	}{
 		\If{has no one child}{
 			\Return auxiliar->next\_hop\;
 		}
 		auxiliar:=auxiliar->one\;
 	}
 }
 \Return -1\;
 \caption{AdressLookUp}
\end{algorithm}
\section{Considerações finais}

\end{document}